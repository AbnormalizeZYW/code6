#include <iostream>

using namespace std;

// 暴力做法
void test1()
{
    int a = 2, b = 5;
    int ans = 1;
    for (int i = 0; i < b; ++ i ) ans *= a ;
    
    cout << ans << endl;
}

// 每次循环都是 a^(a^k-1)^2

void test2()
{
    int cnt = 0;        // 会循环 3 次
    
    int a = 2, b = 5;   // a^b
    int ans = 1;    
    for (; b; b >>= 1)
    {
        if (b & 1) ans = ans * a;   // (b&1)代表如果指数的二进制位为 1, 就加入答案(ans)
        a *= a;
    }
    cout << ans << endl;
}


//    b = 5
//      = 101
//      = 2^0 + (0不需要加) + 2^2
//    a = 2 
//    二进制有几位整个循环就需要乘几次, a 就需要乘 3 次
//    也就是预处理出 a 的 2 的 i 次方
//    假设求 2^5
//
// 1) 就是预处理出 2^(2^0)        -> (2^0这一步, 其实没有通过 a*a 来算, 底数直接拿来用)       
//    由上一步可以得到 2 的 2 的 0 次方的平方
//        ↓
// 2) (2^(2^0))^2  -> 也就是 (2^1)^2
//    由上一步可以得到 2 的 2 的 1 次方的平方
//        ↓
// 3) (2^(2^1))^2 -> 也就是 4^2
//
// (b&1)代表如果指数的二进制位为 1, 就加入答案(ans)
// 因为任何一个数都可以由若干指数不重复的2的次幂组成
// ans = 2^(2^i) * 2^(2^j) * 2^(2^k)...                 -> (假设求2^5)
//     = 2^(2^i+2^j+2^k..)
// 也就是从预处理出的数挑出指数二进制为 1 时得到的答案  
// 由上面 3 步也就是挑出: (1) (3)
//   2^(2^0) * (2^(2^1))^2
// = 2^(2^0 + 2^(2^1))
// = 2^5
// 2
// 也就是 a^b 的计算的次数是根据指数(b) 的二进制位得到的
// 无符号最大的整数为 4294967295, 开 log2 也就是 32
// 与之相同, 一个整数(int) 有 4 个字节, 每一个字节有 8 位(bit)
// 也就是一个整数有二进制位有 32 位
// 所以是 k = [log₂(b+1)], k 也就是 b 的位数 
//
// 为什么会出现这种情况:
// 因为 2^0 = 1, 并且 2 和 1 差 1
// 所以可以组成任何数

int main()
{
    test1();
    // test2();
    return 0;
}