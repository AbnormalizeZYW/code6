// 求在 0~m 之间选择一个整数 x, 经过给定的 n 次位运算, 使得结果 ans 最大
// 
// 从高位枚举依进行 n 次位运算, 看看该位是否可以变成 1 
// 
//      位运算主要特点之一就是在二进制表示下不进位, 所以参与位运算的的各个位是独立的
// 也就是说 ans 的第 k 位只与 x 的第 k 位有关
// 所以可以从高位到低位, 依次考虑 x 的每一位填 0 还是 1
//
// x 的第 k 位填 1, 当且仅当同时满足下列两个条件
// 1) 已经填好的更高位构成的数值加上 1 << k 后不超过 m
// 2) 如果该位填 1 后, 所得到的数对 n 个数都运算之后, 结果小于等于该位填 0 后得到的结果, 
//    那么为了让剩下能填的数更大, 该位填 0 否则该位填 1
//
// 所以我们只需要得到填出来的数对所有数运算的结果, 而并不需要输出填出来的数, 所以在写代码的时候并不需要真正的把数填出来, 
// 只需要确定是否能将答案的该位填成 1 即可
//
// 时间复杂度
// 一共要判断 logm 次，每次判断是 O(n) 的，所以总的时间复杂度是 O(nlogm)

#include <iostream>

const int N = 100005;

int n, m;
int ans;
int t[N];       // t 存输入的 n 的个数
short op[N];    // op 存 n 个数对应的操作, 1 表示 '|', 2 表示 '^', 3 表示 '&'
char str[4];    // str 读入操作

// calc 用于计算 x 经过的所有数的第 j 位操作后所得的结果
bool calc(bool x, int j)       
{
    for (int i = 0; i < n; ++ i )
        if (op[i] == 1) x |= t[i] >> j & 1;  
        else if (op[i] == 2) x ^= t[i] >> j & 1;
        else x &= t[i] >> j & 1;
    return x;
}

int main()
{
    // 一共经过 n 次位运算, 从 0~m 中选最好的结果
    scanf("\n%d%d", &n, &m );
    for (int i = 0; i < n; ++ i )
    {
        scanf("%s%d", str, t + i);
        if (*str == 'O') op[i] = 1;            // OR
        else if (*str  == 'X') op[i] = 2;   // XOR
        else op[i] = 3;    // AND
    }

    // 本题中 m 最大是 10^9, log2(10^9) = 3log2(10^3) < 3 * 10 = 30, 所以每次 i 从 29 往后枚举就可以了 
    for (int i = 29; ~i; -- i)  
        if (1 << i <= m)    // 如果填 1 后 <= m, 要看对答案的影响来填
        {
            // 该位填 0 可以得到的数和该位填 1 得到数对比
            bool x = calc(0, i), y = calc(1, i);        // 分别处理该位填 0 的结果和填 1 的结果
            if (x >= y) ans |= x << i;                  // 如果该位填 1 并不比该位填 0 更优, 那么为了让剩下能填的数更大, 在该位填 0
            else ans |= y << i, m -= 1 << i;            // 否则在该位填 1，填完后让 m 减去该位填 1 的结果，这样在后面填数的时候只用考虑是否大于 m 就可以了
        }
        else ans |= calc(0, i) << i;    // 该位只能填 0 
    
    printf("%d\n", ans);
    return 0;
}