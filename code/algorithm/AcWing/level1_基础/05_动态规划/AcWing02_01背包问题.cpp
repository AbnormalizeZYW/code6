
// 01背包问题:要么用要么不用, 每件物品只能使用一次
// 体积:v[i]
// 价值:w[i]

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;       // n 件物品, m 体积 
int v[N], w[N]; 
int f[N][N];


// 4 5 -> 物品 4 件, 重量 5
// 
// 1 2
// 2 4
// 3 4
// 4 5
// 
// v { 1 2 3 4 }
// w { 2 4 4 5 }
//     1 2 3 4
// 
//      0  1  2  3  4  5   -> 容量
//      __|__|__|__|__|__
//   0   0  0  0  0  0  0 
//      __|__|__|__|__|__
//   1   0  2  2  2  2  2
//      __|__|__|__|__|__
//   2   0  2  4  6  6  6  
//      __|__|__|__|__|__
//   3   0  2  4  6  6  8
//      __|__|__|__|__|__
//   4
//      __|__|__|__|__|__
//   5
//      __|__|__|__|__|__
// 
// 包括: 
//  如果 j(重量够的情况下) >= w[i], 
//  在第 i - 1 的物品中删除(上次做过的最好决策 j-v[i] 那次的最好决策), 
//  到装的下的第 i 个物品的格子中拿那次的最好决策 + 第 i 个物品
//  
//  每次第找上一层格子符合第 i 个物品的决策
// 
// 不包括:
//  不包括, 第 i 个物品
void test()
{
    cin >> n >> m;

    for (int i = 1; i <= n; ++ i) 
        cin >> v[i] >> w[i];

    // 去掉第 i 个物品求最大值, 再加上第 i 个物品
    // 包含第 i 个物品的时候最大值是 j 
    // 体积一开始是最大的 j-v[i], 留出第 i 个物品的位置
    // 
    // f[0~n][0~m]: 枚举所有的状态
    // f[0][0~m] = 0: 一件物品都没选的情况 
    // 考虑前 0 个物品
    // 
    // 从前 i 件物品中选择, 不超过 j   
    for (int i = 1; i <= n; ++ i)
    {
        // 重量一直都在递增
        // 直接从 v[i] 开始会导致之前的依赖错误,
        // 每个格子的重量从 0 开始都有一个答案, 直接从 v[i] 开始会导致
        // 当前层 i 的答案没有收集到, 导致之后的 i+1 层答案全错的 
        for (int j = 0; j <= m; ++ j)
        {
            // 不包括第 i 个物品, 从之前决定的选择, 左边部分一定在!
            f[i][j] = f[i - 1][j];

            // 边界:如果 j < v[i], 体积装不下 v[i] 的时候
            //     最大容量为 j 的时候 
            //     去 i - 1 层格子中到装的下第 i 个物品的格子中拿答案 + 第 i 个物品的权重
            //     两个集合求 max
            if (j >= v[i]) 
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
}

int main()
{
    test();
    return 0;
}

