// 选或者不选
// 状态表示f(i,j):所有选法中的最大价值
// 属性:Max
// 
// 状态计算:
//  - 集合划分:选和不选
//      1) 不选当前 i 号物品, 取之前枚举到当前容量的最优解 f[i-1][j]
//      2) 选择当前 i 号物品, 如果当前枚举到的容量大于当前物品的重量, 找到之前格子的能装下当前物品的最优解
//         f[i][j] = f[i - 1][j - v[i]] + w[i]

#include <iostream>
#include <algorithm>

using namespace std;

// 个数, 体积
const int N = 1010, M = 1010;

int n, m;
int v[N], w[N];     // 个数的属性: 重量, 价值
int f[M];           // N/M:选择某个物品下的重量, 不选某个物品下的重量
                    // 集合:最大价值
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    
    for (int i = 1; i <= n; ++ i) scanf("%d%d", &v[i], &w[i]);
    
    for (int i = 1; i <= n; ++ i)
        for (int j = m; j >= v[i]; -- j)
        {
            // 枚举每个物品在不同容量时的状态
            // 第 1 件物品在容量为 0 的时候, 依赖上个格子, 也是 0  
            // 当枚举到满足第 1 件物品的容量时, 上次的最优解为当前获取档前物品腾出空间, 求 max
            
            // 证明为什么不存在遗漏:每个物品选择和不选择情况下的最优解 (走读代码)
            //                      容量一直都存在递增行为, 直到能装下第 i 个物品, 在拿下的同时也会去找没有第 i 个物品的情况下
            //                      (因为装不下, j-v[i]会减到正好装得下那个物品)
            //                      找最优解来装下自己
            // 
            // 为什么当前容量(j)的一定是最优解: 因为物品是从装和不装一个个枚举下来的, 每个 j 都代表了装了哪些物品(某条路径的选择)
            //                                  经过了路径之间的对比, 得到的最解
            
            f[j] = max(f[j], f[j - v[i]] + w[i]);   // 之前选择里的最优解
        }
        
    printf("%d", f[m]);
        
    return 0;
}