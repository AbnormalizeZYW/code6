
// 思路2:
// 状态表示f[i,j]:所有总和是 i, 并且恰好表示成 j 个数的方案
// 属性: 数量
// 集合: 最小值是 1, 最小值大于 1 (这样的表示就不重不漏)
//       1) 由于 f[i][j] 最小值是 1, 那么每一个方案都存在一个 1 
//          将每个方案的 1 去掉, 就会表示成和是 i-1, 表示成 j-1 个数的和
//          f[i - 1][j - 1]
// 
//       2) 总和是 i, 接下来改成严格大于 1, 所以每个数减去一个 1, 所以还是整数 
//          f[i - j][j] 每个方案拿出来 -1, 总和会减去 j

