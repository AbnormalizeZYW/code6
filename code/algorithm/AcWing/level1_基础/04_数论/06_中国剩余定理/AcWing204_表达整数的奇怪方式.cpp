// part1:
// 
// 中国剩余定理: 给定一堆两两互质的数 m₁ m₂ ~ mₖ 两两互质
// 使得:
//    x≡a₁(mod m₁)
//    x≡a₂(mod m₂)
//    ... ...
//    x≡aₖ(mod mₖ)
// 
// 一:公式
//   1)
//      M = m₁·m₂·...·mₖ
//      Mᵢ = M / mᵢ => Mᵢ 等于除了 mᵢ 之外所有数的乘积
//      由于所有的 m 是两两之间互质的, 所以 mᵢ 就和 M / mᵢ 互质, 就可以求出 Mᵢ 的逆元, 记作 Mᵢ^-1. 
//      Mᵢ^-1 表示 Mᵢ 表示模 mᵢ 的逆, 记作 Mᵢ·Mᵢ^-1≡1(mod mᵢ) (可求出)
//      因为是数之间是两两互质的, 所以 mᵢ 和除了 mᵢ 以外的数的乘积互质, 所以这个逆是存在的   
// 
// 为什么 Mᵢ 和 mᵢ互质 ? 
// 因为 Mᵢ 不是 mᵢ 的倍数
// 
//  2) 
//      通解 x = a₁·M₁·M₁^-1 + a₂·M₂·M₂^-1 + ... + aₖ·Mₖ·Mₖ^-1
//      例: x % m₁
//          ∵ M₂, M₃...Mₖ 是 m₁ 的倍数 (Mᵢ 计算时只有自己的 mᵢ 没有算入乘积, 所以除了 M₁ 外都是 m₁ 的倍数)
//          ∴ (a₂·M₂·M₂^-1 + a₃·M₃·M₃^-1 + ... + aₖ·Mₖ·Mₖ^-1) % m₁ = 0
//          ∵ M₁·M₁^-1 % m₁ = 1
//          ∴ (a₁·M₁·M₁^-1) % m₁ = a₁ % m₁
//
// 求逆元的话可以用扩展欧几里得, 等价于解 ax≡1(mod m)(特殊的线性方程)
// 通解就被称为中国剩余定理
//  
// 二:中国剩余定理扩展(m₁, m₂...mₙ不互质, 且求 x 的非负整数解最小值)
//    x≡a₁(mod m₁) (1)
//    x≡a₂(mod m₂) (2)
//    ... ...
//    x≡aₖ(mod mₖ) (n)
//    将 (1), (2) 两式单独拿出, 并且可没
//       x = k₁a₁ + m₁ (1)
//                        =>  k₁a₁ + m₁ = = k₂a₂ + m₂  => k₁a₁ - k₂a₂ = m₂ - m₁ => 用扩展欧几里得可求出 k₁, k₂
//       x = k₂a₂ + m₂ (2)
//       
//    进而可求得 k₁, k₂ 的解集:
//       k₁+k·a₂/d 
//       k₂+k·a₁/d
//    其中 d 为 a₁, a₂ 的最大公因数, 所以上述过程中, 如果 (m₂ - m₁) 不为 d 的倍数, 则无解
// 
// 证明 k₁, k₂ 的解集: 将 k₁, k₂ 代入 (1) (2) 中
//  x = a₁(k₁+k·a₂/d) + m₁ = a₁k₁ + k(a₁a₂)/d + m₁
//  x = a₂(k₂+k·a₁/d) + m₂ = a₂k₂ + k(a₂a₁)/d + m₂ 
//  ∵ a₁k₁ + m₁ = a₂k₂ + m₂
//  ∴ a₁k₁ + k(a₁a₂)/d + m₁ = a₂k₂ + k(a₂a₁)/d + m₂, 故得证
// 
// 
// part2:
//  1) 将式子等价转换:
//      转换:取余的话不是很好做推导, 所以转换成乘法
//      根据上面的式子可以得到 x₁ = k₁·a₁+m₁, x₂ = k₂·a₂+m₂
//      则:
//      k₁·a₁+m₁ = k₂·a₂+m₂
//      k₁·a₁-k₂·a₂ = m₂ - m₁
//  (1) k₁·a₁ + k₂·(-a₂) = m₂ - m₁  => ax + by = c 的形式可以用扩展欧几里得算法求解
//      因为 a₁,a₂,m₁,m₂ 是给定的, 去求 k₁, k₂, 等价于 (a₁,a₂)|m₂-m₁
//      也就是要找到一个最小的 k₁, k₂ 使得等式成立(因为要求 x 最小, 而 a 和 m 都是整数)
//  
// 2) 用扩展欧几里得算法找出一组解:
//    我们已知 a₁, m₁, a₂, m₂, 可以用扩展欧几里得算法求出 k₁', k₂' 使得:
//    k₁'·a₁ + k₂'·(-a₂) = gcd(a₁, -a₂)
//
//    无解判断:
//       - 若 gcd(a₁, -a₂)∤ m₂-m₁, 则无解
//    有解:
//      设: d = (a₁, - a₂), y = (m₂ - m₁) / d, y∈Z*
//          (因为除的是最大公因数, 所以 y 也是个质数)
//      承接上文, 只需让 k₁, k₂ 分别扩大 y 倍, 则可以找到一个 k₁, k₂ 满足 (1) 式
//      k₁ = k₁'· y, k₂ = k₂'· y
//

#include <iostream>

using namespace std;

typedef long long LL;

// 扩展欧几里得求 ax+by=gcd(a,b) 的解
LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if(b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    LL x1, y1, gcd = exgcd(b, a%b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return gcd;
}

int main()
{
    int n, has_ans = 1; scanf("%d", &n);
    LL a1, m1, t; scanf("%lld%lld", &a1, &m1); // 第一个方程的系数, 备份数据 \ 输入第一个方程
    
    // 1) 得到 x₁ = k₁·a₁+m₁, x₂ = k₂·a₂+m₂ => k₁·a₁ + (-k₂)·a₂ = m₂ - m₁ 

    for (int i = 2, a2, m2; i <= n; ++ i )  // 拼凑接下来的 n-1 个方程
    {
        scanf("%d%d", &a2, &m2);
        LL k01, k02, d = exgcd(a1, a2, k01, k02);  // 2) 利用扩展欧几里得到该方程的 k₁, k₂

        // 设 k₀₁, k₀₂ 为 a₁·k₀₁ + a₂·k₀₂ = gcd(a₁, a₂) 方程的解, 则 gcd(a1,a2)|m₂ - m₁ 时方程有解
        // gcd(a₁, a₂) 记作 d, 求出通解将通解代入原方程
        // k₁ = k₀₁·(m₂-m₁)/d + k·(a₂/d)
        // k₂ = k₀₂·(m₂-m₁)/d + k·(a₁/d)
        // ps:为了防止溢出, 则需要在通解 k₁ 中选出一个尽可能小的特解 k₀₁, 此处为取最小正整数特解
        //    令 k₀₁ = k₀₁·(m₂-m₁)/d
        //    则最小正整数特解为:
        //         - k₀₁ = (k₀₁ % d + a₂ + d) % a₂ / d
        if ((m2 - m1) % d)  // 此时无解
        {
            has_ans = 0;
            break;
        }

        k01 = k01 * (m2 - m1) / d;  // 特解
        k01 = (k01 % (a2 / d) + a2 / d) % (a2 / d);   // 让特解 k₀₁ 取得最小正整数解

        // 将 k₁ 代入 x₁ = k₁·a₁+m₁
        // k₁ = k₀₁·(m₂-m₁)/d + k·(a₂/d)
        // k₀₁ = k₀₁·(m₂-m₁)/d              ps:看做一个整体
        // 
        // x = a₁(k₀₁·(m₂-m₁)/d + k·(a₂/d)) + m₁
        //   = a₁·k₀₁·(m₂-m₁)/d + k·a₁a₂/d + m₁
        //   = a₁·k₀₁·(m₂-m₁)/d + k·[a₁,a₂] + m₁
        // 
        // 
        // a = a₁a₂/d
        // m = k₁a₂ + m₁
        t = a1 * a2 / d;        // a₁a₂/(a₁, a₂) = [a₁, a₂]
        m1 = a1 * k01 + m1;     // m = a₁ + k₀₁ + m₁
        a1 = t;
    }
    if (has_ans) printf("%lld", (m1 % a1 + a1) % a1);
    else printf("%d\n", -1);
    return 0;
}