// 将系数抽出, 得到一个系数矩阵, 对这个系数矩阵进行初等行列变换操作
// 最终转化成最简阶梯型矩阵
// 1) 把某一行乘一个非零的数
// 2) 交换某两行 
// 3) 把某行的若干倍加到另一行
// 这 3 种行列变换是等价变换, 保证我们不会影响方程组最终解
//
// 初等行列变换: 完美阶梯型 => 唯一解
//              不是完美阶梯型(比如第一行有 n 个未知数, 第二行剩下 n-2 个, 那么到最后就不会剩下 n 个方程): 
//                  - 出现左边没有未知数, 右边系数是非 0 的, 这就矛盾了 => 无解
//                  - 出现很多 0 = 0 的方程, 也就是说这些方程可以被其他方程表示出来, 
//                    是多余的那就说明有 n 个未知数但是有 n-1 个方程 => 表示有无穷多组解
// 
// 高斯消元:
//      - 枚举每一列 c
//          1) 找到绝对值最大的一行
//          2) 将该行换到最上面去
//          3) 将该行第一个数变成 1
//          4) 将下面所有行的第 c 列消成 0
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 110;
// c++ 存储浮点数是有误差的, 所以不能直接判断 0, 只先能判断一个很小的数
const double eps = 1e-6;    

int n;
double a[N][N];

int gauss()
{
    int c, r;  // c:表示枚举的哪一列, r:表示枚举哪一行
    for (c = 0, r = 0; c < n; ++ c )  // 从第 0 列第 0 行开始枚举
    {
        int t = r;
        for (int i = r; i < n; ++ i ) // 1) 找到当前这列绝对值, 最大的那一行
            if (fabs(a[i][c]) > fabs(a[t][c])) // 如果当前行第 c 列绝对值大于第 t 列绝对值 
                t = i;                         // 交换

        //  如果当前这一列的最大数都是 0, 那么所有数都是 0, 就没必要去算了, 因为它的约束方程, 可能在上面几行
        if (fabs(a[t][c]) < eps) continue;

        // 2) 当前这一行每列局绝对值最大的那个数换到非固定方程上
        //      - 将选出的第 t 行的第 i 列和第 r 行的第 i 列交换
        for (int i = c; i <= n; ++ i ) swap(a[t][i], a[r][i]);
        // 3) 将当前行第一个数变成 1, 也就是这个方程等式两边同时除以 第一个数
        //      - 必须倒着算, 如果第一个数先变成 1, 系数就被篡改, 后面的数没法算
        for (int i = n; i >= c; -- i ) a[r][i] /= a[r][c];
        // 4) 把当前列下面所有的数, 全变成 0
        for (int i = r + 1; i < n; ++ i )
            if (fabs(a[i][c]) > eps)       // 已经是 0 的没必要操作
                for (int j = n; j >= c; -- j ) // 从后往前, 当前行的每个数字, 都减去对应列 * 行首非 0 的数字, 这样就能保证第一个数字是 a[i][0] -= 1*a[i][0]
                    a[i][j] -= a[r][j] * a[i][c];

        ++ r;  // 当前行做完做下一行
    }

    // 说明剩下方程的个数是小于 n 的, 说明不是唯一解, 判断无解还是无穷多解
    // 因为已经是阶梯型, 所以 r - n-1 的只应该都为 0
    if (r < n)  
    {
        for (int i = r; i < n; ++ i )
            if (fabs(a[i][n]) > eps) return 2; // a[i][n] 代表 b_i, 即 左边 = 0, 右边 = b_i, 0 != b_i, 所以无解
        return 1;
    } 

    // 唯一解, 从下往上回代, 得到方程的解
    for (int i = n - 1; i >= 0; -- i )
        for (int j = i + 1; j < n; ++ j )
            a[i][n] -= a[i][j] * a[j][n];   // 因为只要得到解, 所以只能对 b_i 进行操作, 中间值, 可以不用操作
    return 0;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; ++ i )
        for (int j = 0; j < n + 1; ++ j ) 
            scanf("%lf", &a[i][j]);
    
    int t = gauss();
    
    if (t == 0) 
        for (int i = 0; i < n; ++ i )
        {
            if (fabs(a[i][n]) < eps) a[i][n] = 0;
            printf("%.2lf\n", a[i][n]);
        }
    else if (t == 1) puts("Infinite group solutions");
    else puts("No solution");

    return 0;
}
