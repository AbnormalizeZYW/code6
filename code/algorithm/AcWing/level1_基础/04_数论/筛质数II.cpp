void get_primes()
{
    //外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定
    for(int i = 2; i <= n; i ++ )
    {
        if(!st[i]) primes[cnt ++ ] = i;
        for(int j = 0; primes[j] <= n / i; j++) // primes[j]<=n/i:变形一下得到—— primes[j] * i <= n, 把大于n的合数都筛了就没啥意义了
        {
            
            st[primes[j] * i] = true;         // 用最小质因子去筛合数

            //1) 当 i%primes[j]!=0 时,说明此时遍历到的 primes[j] 不是i的质因子，那么只可能是此时的 primes[j]<i 的
            //   最小质因子, 所以 primes[j]*i 的最小质因子就是 primes[j] 
            // 
            //2) 当有 i%primes[j]==0 时, 说明 i 的最小质因子是 primes[j], 因此 primes[j]*i 的最小质因子也就应该是
            //   prime[j], 之后接着用 st[primes[j+1]*i] = true 去筛合数时, 就不是用最小质因子去更新了, 因为 i 有最小
            //   质因子 primes[j] < primes[j+1], 此时的 primes[j+1] 不是 primes[j+1]*i 的最小质因子, 此时就应该
            //   退出循环，避免之后重复进行筛选。
            if(i % primes[j] == 0) break;
        }
    }
}


// 本质上用最小质数来排除合数
//    它将 p[j]*i 和 i 都排除了, 与此同时 p[j] 可以同时作为 i 和 p[j] * i 的最小质因数 
//    知道了他们的最小质因数, 他们就可以作为合数被排除, 既然有质因子那就一定不是质数, 
//    所以剩下的 n 以内的质数, 因为枚举了每个数的最小质数, 所以每个数都会枚举到
//   
// 1) 它只考虑了, p[j]*i <= n, 也就是说只考虑了 n 以内的合数
//    枚举的数都是 < n 的, j 每次从最小枚举, 所以 j 不会超过 i 也就是 p[i] % j == 0 就会 break
//    或者超过 n / i 就 break, 这两点保证了 O(n), 枚举过的合数不枚举, 每个数最多被筛一次   
//
//    一旦找到最小质因数或者超出枚举范围就退出循环避免重复筛选
// 
// 2) 如果 i % p[j] != 0, 那么就说明, p[j] 不是 i 的最小质因子, p[j] 是 < p[j]*i 的最小质因子且 p[j] < i
//    因为 j 从小到大枚举, p[j] == i, 就会 break 
// 
//    因为每次从小到大枚举, 所以 p[j] 一定是 i 的最小质因数
// 3) i % p[j] == 0, 说明 p[j] 是 i 的最小质因数, 也是 i * p[j] 的最小质因子, i 是 i * p[j] 的最大因数
//    p[j] 作为 i 的最小质因子, 下次循环就不是 p[j + 1] 去更新, 因为 i 的最小质因子是 p[j]
//    所以只要 i % p[j] == 0, 就跳出循环, 避免重复筛选  