// Q: 为什么要保持栈内元素大小的单调递增特性 ?
// A: 由于栈内元素是递增的, 所以比较次数一定是最少的, 这就实现了优化
// Q: 如何保持栈内元素大小的递增性 ?
// A: 在依次出栈比较栈顶元素和当前数组元素大小的时候, 如果栈顶元素小, 那么找到目标值, 将当前数组元素入栈, 这样保持了栈内元素大小的递增性
//    如果栈顶元素大, 那么栈顶指针左移, 直到找到目标值, 再将当前数组元素入栈, 这样就保持了栈内元素大小的递增性
//    我们不必在意这个过程破坏了栈的结构, 因为之前的数已经找到之前数组元素对应的目标值了
// 如果栈顶数据 >= x, 就弹出
//
// 应用场景 : 单调栈的特点找到左边/右边离他最近的数
// 因为每次都要找最左边比自己小的, 也就是说最后的结果严格单调递减, 比当前数大的都可以排除掉
#include <iostream>

using namespace std;

const int N = 100010;

int stk[N], tt;

// 输出每个数左边第一个比它小的数
// 维护 stk[i-1] < stk[i], 一直维护栈顶元素是最小的
// 输出每个数左边第一个比它小的数, 如果不存在则输出 −1
// 也就是说左边
int main()
{
    int n;
    scanf("%d", &n);
    
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;    // 如果栈顶元素小那么当前的 x 就找到目标值
        if (!tt) printf("-1 ");
        else printf("%d ", stk[tt]);
        stk[ ++ tt] = x;
    }

    return 0;
}
