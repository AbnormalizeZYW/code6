
// 暴力做法是将整个模板串往后移动一位, 重新开始匹配
// 但是可以发现, 其实可以不需要重新开始匹配, 因为之前已经匹配过了
// 匹配到不匹配的字符, 才会发生重新匹配这个行为, 也就是说之前是有相同字符的
// 我们不需要全部都重新匹配
// 暴力做法将模板串往后移动一位, 对应主串, 从后面一位开始匹配太慢了
// 所以我们要考虑的就是将模板串最多往后移多少就可以重新开始匹配
// 
// 核心思想:在每次失配时, 不是把 p 串往后移一位, 而是把 p 串往后移动至下一次可以和前面部分匹配的位置
//          这样就可以跳过大多数的失配步骤, 而每次 p 串移动的步数就是通过查找 next[] 数组确定的
//
// next[i]含义:以 i 为终点的后缀和从 1 开始的前缀相等, 后缀的长度最长
// 求模板串后缀和前缀相等, 相等的最大长度是多少
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
char p[N], s[M];
int ne[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;
    // 预处理 next 数组:
    //  0 号位置代表要从新匹配, 不存储长度, 1 号位置根本就不存在前缀串所以 i 从 2 开始
    //  0 是判断是否需要重新来过的位置, 所以 j 从 0 开始   
    //  ps:因为是 p 的第 i 位和 p 的 j+1 位比较, 这有一个加 1, 从 0 开始还可以防止越界(和前缀和一个道理) 
    for (int i = 2, j = 0; i <= n; ++ i )
    {
        while(j && p[i] != p[j + 1]) j = ne[j];   // 如果前后缀不匹配 j 就一直往回退, 直到 j 为 0
        if (p[i] == p[j + 1]) ++ j;
        ne[i] = j;
    }

    for (int i = 1, j = 0; i <= m; ++ i )
    {
        // 如果 j 还没有退回起点(退回起点就要重新开始匹配了), 并且主串不能和模板串的下一位去匹配 
        // 就要想模板串最少往后移动多少使得, 也就是让最大后缀等于前缀
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)     // 匹配成功
         {
            printf("%d ", i - n);       // 该题下标从 0 开始不要-1
            j = ne[j];  // 因为ne[j]求的是最大匹配所以对应最小移动, 保证不遗漏
         }    
    }
    return 0;
}