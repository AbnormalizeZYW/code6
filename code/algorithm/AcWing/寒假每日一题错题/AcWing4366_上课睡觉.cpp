// 分析: 如果每一堆石子有 cnt 个, 那么最终一定有 sum/cnt 堆石子 且 cnt|sum
//       所以可以枚举每个 cnt 是否可以取到, 在所有可以取到的 cnt 中找操作数量最少的一个
//       如果每一堆有 cnt 个, 则一共有 sum/cnt 堆, 初始有 n 堆, 想合并到 sum/cnt 堆
//       每次操作减少 1 堆, n - 1x = sum/cnt, 也就是有 n-sum/cnt 次操作次数 
//                              x = n - sum/cnt
//       因为我们需要的操作次数越小越好, 所以 cnt 要越小越好, 因为最坏情况下 cnt 取到 sum
//       该题一定有解, 最坏 n 堆合并成 1 堆
// 
// 如何判断 cnt 是否成立: 判断每堆的数量是否可以变成 cnt, 因为在合并的时候每次最终只能 合并 相邻两堆
//                       所以在原始序列中每一堆都是相邻的一段 (一定是前半段合并完了才会轮到后面)
//                       就相当于问, 能否将序列分成若干段, 使得每一段的数量都是 cnt
//                       所以从前往后枚举每一段即可, 如果 当前总和 < cnt, 说明还不够, 还需要继续往后枚举 
//                       如果 当前总和 > cnt, 说明该方案不成立 (只能合并相邻两堆, 所以不会出现在 不合并距离自己近的情况下 但是 合并离自己远的可以 的情况)
//                       因为去掉一堆小于 cnt, 一定不够
//                       如果 当前总和 = cnt, 如果下一堆数量为 0, 无论加还是不加都可以, 0 属于左边的堆或者右边的堆都可以
//                       如果是 0 不能加, 枚举下一段, 使它等于 cnt
// 
// 能枚举是因为每次操作唯一确定, 每个数 ≥ 0, 如果 < 0, 每次的操作就不是唯一确定
//
// 时间复杂度: sum ≤ 10^6
//            因为 sum ≤ 10^6 且 cnt|sum, 所以 cnt 的数量(堆数) 等于 约数个数
//            一个 10^6 以内的约数最多的数为 720720, 为 240 个约数              - 扩展: int 范围内约数个最多的数 的 约束个数为 1600 

#include <iostream>

using namespace std;

const int N = 100010;

int n;
int w[N];

// 相邻两堆能合并, 每段是否可以平均分为 cnt
bool check(int cnt)
{
    // 相当于自动处理某一堆数量为 0 的情况
    for (int i = 0, s = 0; i < n; ++ i )
    {
        s += w[i];      // 加上当前这一堆
        if (s > cnt) return false;
        if (s == cnt) s = 0;    
    }
    return true;
}

int main()
{
    int T; scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        int sum = 0;        
        for (int i = 0; i < n; ++ i ) 
        {
            scanf("%d", &w[i]);
            sum += w[i];
        }
    
        // 枚举堆数(最坏 1 堆)
        // 堆数越多, 那么操作次数越少 n-sum/cnt (所以从后往前) 
        // if: 如果堆数是总和的约数(约数总归有一对, 枚举堆数 或者枚举 每一堆的数量 都可以)
        // check: 枚举每一堆的数量是否合法
        for (int i = n; i; -- i)
            if (sum % i == 0 && check(sum / i))
            {
                printf("%d\n", n - i);
                break;
            }
    }

    return 0;
}


