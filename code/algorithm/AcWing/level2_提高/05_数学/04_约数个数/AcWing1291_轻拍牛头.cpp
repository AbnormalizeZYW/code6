// 约数个数: N = p1ᶜ¹ · p1ᶜ² · ... · p1ᶜⁿ
//          f(N) = (C₁ + 1)(C₂ + 1)...(Cₖ + 1)
//
// 约数总和: N
//          ∑ f(i)
//         i=1
//
// in :2 1 2 3 4
// out:2 0 2 1 3
// 解释: 2 的约数: 1,2
//       1 的约数:
//       2 的约数: 1,2
//       3 的约数: 1
//       4 的约数: 2,1,2 
// 
// 解: 不去求每个数的约数有多少个, 因为求一个数的约数时间复杂度 √N
//     那么求所有数就是 O(N * √N)
//     试除的时候只除倍数可以稍微优化下, 一直分解诶每个数的质因数是比较困难的
//     但是可以反过来想, 求一个数的倍数, 因为倍数对应的是乘法
//
// 例: 大部分密码基于 RSA, RSA 秘钥基于的事实: 算乘法很简单, 算分解质因数很困难     
//     所以我们可以求哪个数, 可以去算有多少个数是它的倍数, 将 i 出现的次数累加到 j 的答案当中
//     求每个数约数个数有多少个
#include <iostream>

using namespace std;

const int N = 1000010;

int n;
int a[N], cnt[N], s[N];

int main()
{
    scanf("%d", &n);

    // 统计 a[i] 出现的次数
    for (int i = 0; i < n; ++ i )
    {
        scanf("%d", &a[i]);
        cnt[a[i]] ++ ;          
    }

    for (int i = 1; i < N; ++ i )
        for (int j = i; j < N; j += i ) // 枚举 i 的倍数出现了几次加在对应的位置, 只要是 i 的倍数都累计上倍数对应的次数
            s[j] += cnt[i];
    
    // 因为这道题问的是除它自己以外其他的数所以要把自己减去
    for (int i = 0; i < n; ++ i ) printf("%d\n", s[a[i]] - 1);

    return 0;
}