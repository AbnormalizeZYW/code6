// 对于任何正整数 x, 其约数个数记作 g(x), 例: g(1) = 1, g(6) = 4
// 如果某个正整数 x 满足: 对于任意的小于 x 的正整数 i, 都有 g(x)>g(i), 则称 x 为反素数
// 例: 整数 1,2,4,6 等都是反素数
// 给定一个数 N, 请求出不超过 N 的最大反素数 
// 数据范围: 1 ≤ N ≤ 2∗10^9
//
// 素数的定义是只有他自己本身, 也就是自己的约数本身就特别少
// 结论: 约数个数最多的且在区间中最小的数也就是反素数
//    
// |________|_________|
// 1        x        n
// 也就是说, [1,xᵢ₋₁], (xᵢ₋₁ ≥ 1) 的约数个数都小于 x, 且 x 是这个区间 [1,n] 中约数个数最多的一个数, 那么 x 就是个反素数
// 因为 [x,n] 的区间 g(x) > g(xᵢ₊₁), (xᵢ₊₁ ≤ n), 所以 [x+1,n] 的区间的数都不是反素数 (反素数严格要求 g(x) > g(i))
// 
// 1) 对于数据范围 [1,2 * 10^9], 能够满足不同质因子相乘的最大质数为 28:
//    2×3×5×7×11×13×17×19×23×29 > 6×10^9 > 2×10^9
// 
// 2) 对于数据范围 [1,2×10^9], 能够满足质因子的最大次数为 30:
//    2^31 > 2×10^9 (底数越大, 指数只可能更低, 所以次数一定不会超过 30)
// 
// 3) 对于数据范围 [1,2x10^9], 质因子从小到大排序, 其次数必定是单调递减的:
//     N = 2ᶜ¹·3⁴·5⁵·7ᶜ⁴·9ᶜ⁵
//    很明显 3⁴·5⁵ > 3⁵·5⁴
//    因为约数个数和质因子本身是没有关系的, 所以就可以把 3 和 5 的质因子交换一下
// 
//    反证法: 假设存在某两个质因子 a,b, (a>b), a, b 的次数分别记作 ka,kb, ka > kb
//           则对于该反素数 x = ... aᵏᵃ·bᵏᵇ..., 必然存在数 x' = ... aᵏᵃ·bᵏᵇ..., x' < x
//           而根据我们推导的第一个性质, x' 更有可能是所求反素数, 而非 x, 故矛盾
// 总结:      
//  1) 不同的质因子最多只会包含 9 个
//  2) 每个质因子的次数最大是 30
//  3) 所有质因子的次数一定是递减
#include <iostream>

using namespace std;

int primes[9] = {2,3,5,7,11,13,17,19,23};   // primes 一共有 9 个

typedef long long LL;

int n, maxd, num;    // n:输入个数, maxd:约数个数, num:数本身

// u:当前枚举到的质数
// last:上一个的次数
// p:上一个数
// s:约数个数 
void dfs(int u, int last, int p, int s)
{
    // 如果当前约数个数大于最大约数个数, 或者是等于最大约数个数并且 p 小于 num 的话就更新(底数更小的情况)
    if (s > maxd || s == maxd && p < num)   
    {
        maxd = s;       
        num = p;
    }

    // 如果 u 已经的等于 9 了, 表示已经枚举了所有情况了, 可以直接 return 了
    if (u == 9) return; 
    
    // 枚举次数, 次数的话从一次开始枚举, 一直枚举到第 last 次, 不能比上一次多(i 枚举的指数)
    for (int i = 1; i <= last; ++ i )
    {
        if ((LL)p * primes[u] > n) break; // p 乘上一个当前的质数, 看一下是不是已经大于 n 了, 大于 n 直接 break
        p *= primes[u]; // 让 p 就乘上一个 primes[u] 
        dfs(u + 1, i, p, s * (i + 1)); 
    }
}

int main()
{
    scanf("%d", &n);
    
    // dfs 参数: 从第 0 个质数开始枚举, 枚举的最大次数是 30
    // 约数个数的话最开始是 1 , 因为约数个数是通过公式来算的, 每次都要乘上一个数, 所以在没乘之前应该是 1
    dfs(0,30,1,1);

    printf("%d", num);
    return 0;
}
