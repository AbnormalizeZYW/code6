// 一共带 4 头牛, 热任何两个 1 之间至少包含两个 0
// 1 之间至少包含 k 个 0
// 0000 1000 0100 0010 0001 1001 
//
// 划分方式: 倒数第 2 个 1 的位置 
//
// 组合计数: 乘法原理, 加法原理, 组合数, 排列数
//
// 解: 
// f[i]集合: 表示所有长度是 i 的且以 1 结尾的字符串数量 (因为每个 1 之间都要隔开 k 个 0)
// f[i]属性: 方案数 
// 划分方式: f[i] 表示最后一个 1 在第 i 位, s[i] 是 f[i] 的前缀和
// 状态计算: f[i] = f[i - k - 1] + f[i - k - 2] + ... f[0]              => 所有划分方式的方案数累加
// (集合划分的依据是题目要求, 即当前 1 与上一个 1 之间至少要间隔 k 个 0)
// 
// 此处设置一个边界 f[0] 表示只有 0 没有 1 的情况 => f[0] = 1 : 一个方案 
// 根据上述集合的含义: 
// 我们最终的答案就是把所有的 f[i] (包括 f[0], 表示方案全是 0, 没有 1) 累加起来即可

#include <iostream>

using namespace std;

const int N = 1e5 + 10, mod = 5000011;

int n, k;
int f[N], s[N];

int main()
{
    scanf("%d%d", &n, &k);
    
    f[0] = s[0] = 1;
    // 4 - 2 - 1
    for (int i = 1; i <= n; ++ i )
    {
        f[i] = s[max(i - k - 1, 0)];    // 0 用来处理所有的负数边界, 以 1 为结尾, 只要区间够减一个 k, 那就可以放一个 1, 也就是一种方案数. 
                                        // 因为是从 1 开始所以还要多减一个 1
    
        s[i] = (s[i - 1] + f[i]) % mod; // 所有方案生成前缀和数组
    }
    
    printf("%d\n", s[n]);
    
    return 0;
}