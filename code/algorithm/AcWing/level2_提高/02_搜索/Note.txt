搜索基本分为两种, bfs/dfs
第一大类: 走迷宫, 最短路
第二大类: 八数码, 最小步数

不同点:
    第一大类, 走迷宫是求的是一个点走到一个点的最短距离
    第二大类, 可以对图本身进行操作, 我们要求的是从一种图的状态变到另外一种图的状态的最小步数

搜索中的最短路和图论里最短路算法不同, 这是一种特殊的算法算法
处理的是所有边权唯一的情况

FloodFill: 洪水覆盖算法, 给定一个地形图(凹凸不平), 往随机一个格子中注水 
           水会逐渐覆盖所有洼地, 模拟是洼地就覆盖过去, 否在就不能
            

最短路模型: 
多源 BFS: 起点不唯一
最小步数模型: 状态本身是一个点, 整个问题是所有状态之间的逻辑关系
双端队列广搜: 图中边权不唯一, 有的题目不能只在对尾插入, 还需要在队头插入, 这时候就需要双度端队列广搜
双向广搜: 宽搜优化
A*:

BFS: 求最小, 不会爆栈
     个人总结, 其实感觉和 DFS 一样, 都是对自己的同类集合进行归纳
     一样就感染出去, 不一样就看题意判断
     1) 池塘计数问题, 进入队列的全是 'W', 统计完一块 'W' 后队列就停止了(空地直接continue), 当遇到下一块 'W' 继续统计
     2) 城堡问题, 进队列的都是有联通区域的数字, 因为有方向, 一个数字要遍历 4 次才能彻底判断好, 如果是带墙的方向直接 continue 统计下一个方向
        直到周围没有联通区块队列停止循环, 判断过的数字都会被标记为 true, 当遇到下一个没有遍历过的格子继续开始统计
     3) 这题和第一题很像, 如果是自己的同类那就进入队列, 否则就判断自己周围是什么, 如果自己周围只有山峰那自己就是山谷
        反之自己就是山峰, 如果自己周围啥都有, 自己啥也不是, 直到自己的同类全部遍历完, 自己这块区域遍历完, 队列也就停止了

目前 BFS 解决过的问题分类: 
   1) FloodFill 解决区块
   2) 从哪个点走到哪个点
   3) 从哪个状态走到哪个状态



DFS:
1) 连锁反应, 找到一个答案直接返回上去
2) 统计某个状态的个数, 自己的子状态都会返回给它, 搜集起来进行返回  

